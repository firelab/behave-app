// src/persistent_sorted_set_js/ArrayUtil.js
class ArrayUtil {
  static copy(source, srcFrom, srcTo, target, tgtFrom) {
    const len = srcTo - srcFrom;
    for (let i = 0;i < len; i++) {
      target[tgtFrom + i] = source[srcFrom + i];
    }
  }
  static indexedToArray(indexed, arrayType, len) {
    const arr = new Array(len);
    for (let i = 0;i < len; i++) {
      arr[i] = indexed.nth(i);
    }
    return arr;
  }
  static distinct(arr, len, cmp) {
    if (len <= 1)
      return len;
    let writeIdx = 1;
    for (let readIdx = 1;readIdx < len; readIdx++) {
      if (cmp(arr[readIdx - 1], arr[readIdx]) !== 0) {
        arr[writeIdx++] = arr[readIdx];
      }
    }
    return writeIdx;
  }
}

// src/persistent_sorted_set_js/ANode.js
function defaultComparator(a, b) {
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
}

class ANode {
  constructor(len, keys, settings) {
    this._len = len;
    this._keys = keys;
    this._settings = settings;
  }
  len() {
    return this._len;
  }
  minKey() {
    return this._keys[0];
  }
  maxKey() {
    return this._keys[this._len - 1];
  }
  keys() {
    if (this._keys.length === this._len) {
      return Array.from(this._keys);
    } else {
      return this._keys.slice(0, this._len);
    }
  }
  search(key, cmp) {
    let l = 0;
    let r = this._len - 1;
    while (l <= r) {
      const m = l + r >>> 1;
      const c = cmp(this._keys[m], key);
      if (c < 0) {
        l = m + 1;
      } else if (c > 0) {
        r = m - 1;
      } else {
        return m;
      }
    }
    return -(l + 1);
  }
  searchFirst(key, cmp) {
    let l = 0;
    let r = this._len - 1;
    let found = -1;
    while (l <= r) {
      const m = l + r >>> 1;
      const c = cmp(this._keys[m], key);
      if (c < 0) {
        l = m + 1;
      } else if (c > 0) {
        found = m;
        r = m - 1;
      } else {
        return m;
      }
    }
    return found >= 0 ? found : -(l + 1);
  }
  searchLast(key, cmp) {
    let l = 0;
    let r = this._len - 1;
    let found = -1;
    while (l <= r) {
      const m = l + r >>> 1;
      const c = cmp(this._keys[m], key);
      if (c < 0) {
        found = m;
        l = m + 1;
      } else if (c > 0) {
        r = m - 1;
      } else {
        return m;
      }
    }
    return found;
  }
  editable() {
    return this._settings.editable();
  }
  static newLen(len, settings) {
    const expandLen = settings.expandLen();
    return len + expandLen - len % expandLen;
  }
  static safeLen(node) {
    return node == null ? 0 : node._len;
  }
  static restore(level, keys, addresses, settings) {
    throw new Error("Use NodeFactory.restore() instead");
  }
  count(storage) {
    throw new Error("count() must be implemented");
  }
  level() {
    throw new Error("level() must be implemented");
  }
  contains(storage, key, cmp) {
    throw new Error("contains() must be implemented");
  }
  add(storage, key, cmp, settings) {
    throw new Error("add() must be implemented");
  }
  remove(storage, key, left, right, cmp, settings) {
    throw new Error("remove() must be implemented");
  }
  walkAddresses(storage, onAddress) {
    throw new Error("walkAddresses() must be implemented");
  }
  store(storage) {
    throw new Error("store() must be implemented");
  }
  str(storage, lvl) {
    throw new Error("str() must be implemented");
  }
  toString(sb, address, indent) {
    throw new Error("toString() must be implemented");
  }
}

// src/persistent_sorted_set_js/Stitch.js
class Stitch {
  constructor(target, offset) {
    this.target = target;
    this.offset = offset;
  }
  copyAll(source, from, to) {
    if (to >= from) {
      if (source != null) {
        for (let i = from;i < to; i++) {
          this.target[this.offset++] = source[i];
        }
      } else {
        this.offset += to - from;
      }
    }
    return this;
  }
  copyOne(val) {
    this.target[this.offset++] = val;
    return this;
  }
}

// src/persistent_sorted_set_js/Leaf.js
var EARLY_EXIT = [];
var UNCHANGED = [];

class Leaf extends ANode {
  constructor(len, keys, settings) {
    if (Array.isArray(keys) && keys.length >= len) {
      super(len, keys, settings);
    } else if (typeof keys === "object") {
      const actualSettings = settings || keys;
      const newLen = ANode.newLen(len, actualSettings);
      super(len, new Array(newLen), actualSettings);
    } else if (Array.isArray(len)) {
      const actualKeys = len;
      const actualSettings = settings || keys;
      super(actualKeys.length, Array.from(actualKeys), actualSettings);
    } else {
      throw new Error("Invalid Leaf constructor arguments");
    }
  }
  level() {
    return 0;
  }
  count(storage) {
    return this._len;
  }
  contains(storage, key, cmp) {
    return this.search(key, cmp) >= 0;
  }
  add(storage, key, cmp, settings) {
    let idx = this.search(key, cmp);
    if (idx >= 0) {
      return UNCHANGED;
    }
    const ins = -(idx + 1);
    if (this._len < this._settings.branchingFactor()) {
      if (this.editable()) {
        for (let i = this._len;i > ins; i--) {
          this._keys[i] = this._keys[i - 1];
        }
        this._keys[ins] = key;
        this._len++;
        return EARLY_EXIT;
      }
      const newKeys = new Array(this._keys.length);
      new Stitch(newKeys, 0).copyAll(this._keys, 0, ins).copyOne(key).copyAll(this._keys, ins, this._len);
      return [new Leaf(this._len + 1, newKeys, settings)];
    }
    const half1 = this._len + 1 >>> 1;
    const half2 = this._len + 1 - half1;
    if (ins < half1) {
      const keys12 = new Array(half1);
      const keys22 = new Array(half2);
      new Stitch(keys12, 0).copyAll(this._keys, 0, ins).copyOne(key).copyAll(this._keys, ins, half1 - 1);
      ArrayUtil.copy(this._keys, half1 - 1, this._len, keys22, 0);
      return [
        new Leaf(half1, keys12, settings),
        new Leaf(half2, keys22, settings)
      ];
    }
    const keys1 = new Array(half1);
    const keys2 = new Array(half2);
    ArrayUtil.copy(this._keys, 0, half1, keys1, 0);
    new Stitch(keys2, 0).copyAll(this._keys, half1, ins).copyOne(key).copyAll(this._keys, ins, this._len);
    return [
      new Leaf(half1, keys1, settings),
      new Leaf(half2, keys2, settings)
    ];
  }
  remove(storage, key, _left, _right, cmp, settings) {
    const left = _left;
    const right = _right;
    const idx = this.search(key, cmp);
    if (idx < 0) {
      return UNCHANGED;
    }
    const newLen = this._len - 1;
    if (newLen >= this._settings.minBranchingFactor() || left == null && right == null) {
      if (this.editable()) {
        for (let i = idx;i < newLen; i++) {
          this._keys[i] = this._keys[i + 1];
        }
        this._len = newLen;
        return EARLY_EXIT;
      }
      const newKeys = new Array(this._keys.length);
      new Stitch(newKeys, 0).copyAll(this._keys, 0, idx).copyAll(this._keys, idx + 1, this._len);
      return [left, new Leaf(newLen, newKeys, settings), right];
    }
    if (left != null && left._len + newLen <= this._settings.branchingFactor()) {
      const joinKeys = new Array(left._len + newLen);
      new Stitch(joinKeys, 0).copyAll(left._keys, 0, left._len).copyAll(this._keys, 0, idx).copyAll(this._keys, idx + 1, this._len);
      return [null, new Leaf(left._len + newLen, joinKeys, settings), right];
    }
    if (right != null && newLen + right._len <= this._settings.branchingFactor()) {
      const joinKeys = new Array(newLen + right._len);
      new Stitch(joinKeys, 0).copyAll(this._keys, 0, idx).copyAll(this._keys, idx + 1, this._len).copyAll(right._keys, 0, right._len);
      return [left, new Leaf(newLen + right._len, joinKeys, settings), null];
    }
    if (left != null && (right == null || left._len >= right._len)) {
      const totalLen = left._len + newLen;
      const newLeftLen = totalLen >>> 1;
      const newCenterLen = totalLen - newLeftLen;
      const newLeftKeys = new Array(newLeftLen);
      const newCenterKeys = new Array(newCenterLen);
      ArrayUtil.copy(left._keys, 0, newLeftLen, newLeftKeys, 0);
      new Stitch(newCenterKeys, 0).copyAll(left._keys, newLeftLen, left._len).copyAll(this._keys, 0, idx).copyAll(this._keys, idx + 1, this._len);
      return [
        new Leaf(newLeftLen, newLeftKeys, settings),
        new Leaf(newCenterLen, newCenterKeys, settings),
        right
      ];
    }
    if (right != null) {
      const totalLen = newLen + right._len;
      const newCenterLen = totalLen >>> 1;
      const newRightLen = totalLen - newCenterLen;
      const rightHead = right._len - newRightLen;
      const newCenterKeys = new Array(newCenterLen);
      const newRightKeys = new Array(newRightLen);
      new Stitch(newCenterKeys, 0).copyAll(this._keys, 0, idx).copyAll(this._keys, idx + 1, this._len).copyAll(right._keys, 0, rightHead);
      ArrayUtil.copy(right._keys, rightHead, right._len, newRightKeys, 0);
      return [
        left,
        new Leaf(newCenterLen, newCenterKeys, settings),
        new Leaf(newRightLen, newRightKeys, settings)
      ];
    }
    throw new Error("Unreachable");
  }
  walkAddresses(storage, onAddress) {
  }
  store(storage) {
    return storage.store(this);
  }
  str(storage, lvl) {
    return this._keys.slice(0, this._len).join(" ");
  }
  toString(sb, address, indent) {
    sb.push(indent);
    sb.push("Leaf addr: " + address + " len: " + this._len + " keys: ");
    sb.push(this._keys.slice(0, this._len).join(" "));
  }
}
Leaf.EARLY_EXIT = EARLY_EXIT;
Leaf.UNCHANGED = UNCHANGED;

// src/persistent_sorted_set_js/Branch.js
var EARLY_EXIT2 = [];
var UNCHANGED2 = [];

class Branch extends ANode {
  constructor(level, len, keys, addresses, children, settings) {
    if (arguments.length === 3 && typeof keys === "object" && keys._branchingFactor) {
      const actualSettings = keys;
      const newLen = ANode.newLen(len, actualSettings);
      super(len, new Array(newLen), actualSettings);
      this._level = level;
      this._addresses = null;
      this._children = null;
      return;
    }
    super(len, keys, settings);
    this._level = level;
    this._addresses = addresses;
    this._children = children;
  }
  level() {
    return this._level;
  }
  ensureAddresses() {
    if (this._addresses == null) {
      this._addresses = new Array(this._keys.length);
    }
    return this._addresses;
  }
  ensureChildren() {
    if (this._children == null) {
      this._children = new Array(this._keys.length);
    }
    return this._children;
  }
  addresses() {
    if (this._addresses == null) {
      return new Array(this._len);
    } else if (this._addresses.length === this._len) {
      return Array.from(this._addresses);
    } else {
      return this._addresses.slice(0, this._len);
    }
  }
  address(idx) {
    if (this._addresses == null) {
      return null;
    }
    return this._addresses[idx];
  }
  setAddress(idx, address) {
    if (this._addresses != null || address != null) {
      this.ensureAddresses();
      this._addresses[idx] = address;
      if (address != null && this._children != null && this._children[idx] instanceof ANode) {
        this._children[idx] = this._settings.makeReference(this._children[idx]);
      }
    }
    return address;
  }
  child(storage, idx) {
    let child = null;
    if (this._children != null) {
      const ref = this._children[idx];
      child = this._settings.readReference(ref);
    }
    if (child == null) {
      child = storage.restore(this._addresses[idx]);
      this.ensureChildren()[idx] = this._settings.makeReference(child);
    } else {
      if (this._addresses != null && this._addresses[idx] != null) {
        storage.accessed(this._addresses[idx]);
      }
    }
    return child;
  }
  setChild(idx, child) {
    this.setAddress(idx, null);
    if (this._children != null || child != null) {
      this.ensureChildren();
      this._children[idx] = child;
    }
    return child;
  }
  count(storage) {
    let count = 0;
    for (let i = 0;i < this._len; i++) {
      count += this.child(storage, i).count(storage);
    }
    return count;
  }
  contains(storage, key, cmp) {
    let idx = this.search(key, cmp);
    if (idx >= 0)
      return true;
    let ins = -(idx + 1);
    if (ins === this._len)
      return false;
    return this.child(storage, ins).contains(storage, key, cmp);
  }
  add(storage, key, cmp, settings) {
    let idx = this.search(key, cmp);
    if (idx >= 0) {
      return UNCHANGED2;
    }
    let ins = -(idx + 1);
    if (ins === this._len)
      ins = this._len - 1;
    const nodes = this.child(storage, ins).add(storage, key, cmp, settings);
    if (nodes === UNCHANGED2) {
      return UNCHANGED2;
    }
    if (nodes === EARLY_EXIT2) {
      return EARLY_EXIT2;
    }
    if (nodes.length === 1 && this.editable()) {
      const node = nodes[0];
      this._keys[ins] = node.maxKey();
      this.setChild(ins, node);
      if (ins === this._len - 1 && node.maxKey() === this.maxKey()) {
        return [this];
      } else {
        return EARLY_EXIT2;
      }
    }
    if (nodes.length === 1) {
      const node = nodes[0];
      let newKeys;
      if (cmp(node.maxKey(), this._keys[ins]) === 0) {
        newKeys = this._keys;
      } else {
        newKeys = this._keys.slice(0, this._len);
        newKeys[ins] = node.maxKey();
      }
      let newAddresses = null;
      let newChildren = null;
      if (node === this.child(storage, ins)) {
        newAddresses = this._addresses;
        newChildren = this._children;
      } else {
        if (this._addresses != null) {
          newAddresses = this._addresses.slice(0, this._len);
          newAddresses[ins] = null;
        }
        newChildren = this._children == null ? new Array(this._keys.length) : this._children.slice(0, this._len);
        newChildren[ins] = node;
      }
      return [new Branch(this._level, this._len, newKeys, newAddresses, newChildren, settings)];
    }
    if (this._len < this._settings.branchingFactor()) {
      const n = new Branch(this._level, this._len + 1, settings);
      new Stitch(n._keys, 0).copyAll(this._keys, 0, ins).copyOne(nodes[0].maxKey()).copyOne(nodes[1].maxKey()).copyAll(this._keys, ins + 1, this._len);
      if (this._addresses != null) {
        n.ensureAddresses();
        new Stitch(n._addresses, 0).copyAll(this._addresses, 0, ins).copyOne(null).copyOne(null).copyAll(this._addresses, ins + 1, this._len);
      }
      n.ensureChildren();
      new Stitch(n._children, 0).copyAll(this._children, 0, ins).copyOne(nodes[0]).copyOne(nodes[1]).copyAll(this._children, ins + 1, this._len);
      return [n];
    }
    let half1 = this._len + 1 >>> 1;
    if (ins + 1 === half1)
      half1++;
    const half2 = this._len + 1 - half1;
    if (ins < half1) {
      const keys12 = new Array(half1);
      new Stitch(keys12, 0).copyAll(this._keys, 0, ins).copyOne(nodes[0].maxKey()).copyOne(nodes[1].maxKey()).copyAll(this._keys, ins + 1, half1 - 1);
      const keys22 = new Array(half2);
      ArrayUtil.copy(this._keys, half1 - 1, this._len, keys22, 0);
      let addresses12 = null;
      let addresses22 = null;
      if (this._addresses != null) {
        addresses12 = new Array(half1);
        new Stitch(addresses12, 0).copyAll(this._addresses, 0, ins).copyOne(null).copyOne(null).copyAll(this._addresses, ins + 1, half1 - 1);
        addresses22 = new Array(half2);
        ArrayUtil.copy(this._addresses, half1 - 1, this._len, addresses22, 0);
      }
      const children12 = new Array(half1);
      new Stitch(children12, 0).copyAll(this._children, 0, ins).copyOne(nodes[0]).copyOne(nodes[1]).copyAll(this._children, ins + 1, half1 - 1);
      let children22 = null;
      if (this._children != null) {
        children22 = new Array(half2);
        ArrayUtil.copy(this._children, half1 - 1, this._len, children22, 0);
      }
      return [
        new Branch(this._level, half1, keys12, addresses12, children12, settings),
        new Branch(this._level, half2, keys22, addresses22, children22, settings)
      ];
    }
    const keys1 = new Array(half1);
    const keys2 = new Array(half2);
    ArrayUtil.copy(this._keys, 0, half1, keys1, 0);
    new Stitch(keys2, 0).copyAll(this._keys, half1, ins).copyOne(nodes[0].maxKey()).copyOne(nodes[1].maxKey()).copyAll(this._keys, ins + 1, this._len);
    let addresses1 = null;
    let addresses2 = null;
    if (this._addresses != null) {
      addresses1 = new Array(half1);
      ArrayUtil.copy(this._addresses, 0, half1, addresses1, 0);
      addresses2 = new Array(half2);
      new Stitch(addresses2, 0).copyAll(this._addresses, half1, ins).copyOne(null).copyOne(null).copyAll(this._addresses, ins + 1, this._len);
    }
    let children1 = null;
    const children2 = new Array(half2);
    if (this._children != null) {
      children1 = new Array(half1);
      ArrayUtil.copy(this._children, 0, half1, children1, 0);
    }
    new Stitch(children2, 0).copyAll(this._children, half1, ins).copyOne(nodes[0]).copyOne(nodes[1]).copyAll(this._children, ins + 1, this._len);
    return [
      new Branch(this._level, half1, keys1, addresses1, children1, settings),
      new Branch(this._level, half2, keys2, addresses2, children2, settings)
    ];
  }
  remove(storage, key, _left, _right, cmp, settings) {
    const left = _left;
    const right = _right;
    let idx = this.search(key, cmp);
    if (idx < 0)
      idx = -(idx + 1);
    if (idx === this._len) {
      return UNCHANGED2;
    }
    const leftChild = idx > 0 ? this.child(storage, idx - 1) : null;
    const rightChild = idx < this._len - 1 ? this.child(storage, idx + 1) : null;
    const leftChildLen = ANode.safeLen(leftChild);
    const rightChildLen = ANode.safeLen(rightChild);
    const nodes = this.child(storage, idx).remove(storage, key, leftChild, rightChild, cmp, settings);
    if (nodes === UNCHANGED2) {
      return UNCHANGED2;
    }
    if (nodes === EARLY_EXIT2) {
      return EARLY_EXIT2;
    }
    const leftChanged = leftChild !== nodes[0] || leftChildLen !== ANode.safeLen(nodes[0]);
    const rightChanged = rightChild !== nodes[2] || rightChildLen !== ANode.safeLen(nodes[2]);
    let newLen = this._len - 1 - (leftChild != null ? 1 : 0) - (rightChild != null ? 1 : 0) + (nodes[0] != null ? 1 : 0) + 1 + (nodes[2] != null ? 1 : 0);
    if (newLen >= this._settings.minBranchingFactor() || left == null && right == null) {
      if (this.editable() && idx < this._len - 2) {
        const ks2 = new Stitch(this._keys, Math.max(idx - 1, 0));
        if (nodes[0] != null)
          ks2.copyOne(nodes[0].maxKey());
        ks2.copyOne(nodes[1].maxKey());
        if (nodes[2] != null)
          ks2.copyOne(nodes[2].maxKey());
        if (newLen !== this._len) {
          ks2.copyAll(this._keys, idx + 2, this._len);
        }
        if (this._addresses != null) {
          const as = new Stitch(this._addresses, Math.max(idx - 1, 0));
          if (nodes[0] != null)
            as.copyOne(leftChanged ? null : this.address(idx - 1));
          as.copyOne(null);
          if (nodes[2] != null)
            as.copyOne(rightChanged ? null : this.address(idx + 1));
          if (newLen !== this._len) {
            as.copyAll(this._addresses, idx + 2, this._len);
          }
        }
        this.ensureChildren();
        const cs2 = new Stitch(this._children, Math.max(idx - 1, 0));
        if (nodes[0] != null)
          cs2.copyOne(nodes[0]);
        cs2.copyOne(nodes[1]);
        if (nodes[2] != null)
          cs2.copyOne(nodes[2]);
        if (newLen !== this._len) {
          cs2.copyAll(this._children, idx + 2, this._len);
        }
        this._len = newLen;
        return EARLY_EXIT2;
      }
      const newCenter = new Branch(this._level, newLen, settings);
      const ks = new Stitch(newCenter._keys, 0);
      ks.copyAll(this._keys, 0, idx - 1);
      if (nodes[0] != null)
        ks.copyOne(nodes[0].maxKey());
      ks.copyOne(nodes[1].maxKey());
      if (nodes[2] != null)
        ks.copyOne(nodes[2].maxKey());
      ks.copyAll(this._keys, idx + 2, this._len);
      if (this._addresses != null) {
        const as = new Stitch(newCenter.ensureAddresses(), 0);
        as.copyAll(this._addresses, 0, idx - 1);
        if (nodes[0] != null)
          as.copyOne(leftChanged ? null : this.address(idx - 1));
        as.copyOne(null);
        if (nodes[2] != null)
          as.copyOne(rightChanged ? null : this.address(idx + 1));
        as.copyAll(this._addresses, idx + 2, this._len);
      }
      newCenter.ensureChildren();
      const cs = new Stitch(newCenter._children, 0);
      cs.copyAll(this._children, 0, idx - 1);
      if (nodes[0] != null)
        cs.copyOne(nodes[0]);
      cs.copyOne(nodes[1]);
      if (nodes[2] != null)
        cs.copyOne(nodes[2]);
      cs.copyAll(this._children, idx + 2, this._len);
      return [left, newCenter, right];
    }
    if (left != null && left._len + newLen <= this._settings.branchingFactor()) {
      const join = new Branch(this._level, left._len + newLen, settings);
      const ks = new Stitch(join._keys, 0);
      ks.copyAll(left._keys, 0, left._len);
      ks.copyAll(this._keys, 0, idx - 1);
      if (nodes[0] != null)
        ks.copyOne(nodes[0].maxKey());
      ks.copyOne(nodes[1].maxKey());
      if (nodes[2] != null)
        ks.copyOne(nodes[2].maxKey());
      ks.copyAll(this._keys, idx + 2, this._len);
      if (left._addresses != null || this._addresses != null) {
        const as = new Stitch(join.ensureAddresses(), 0);
        as.copyAll(left._addresses, 0, left._len);
        as.copyAll(this._addresses, 0, idx - 1);
        if (nodes[0] != null)
          as.copyOne(leftChanged ? null : this.address(idx - 1));
        as.copyOne(null);
        if (nodes[2] != null)
          as.copyOne(rightChanged ? null : this.address(idx + 1));
        as.copyAll(this._addresses, idx + 2, this._len);
      }
      join.ensureChildren();
      const cs = new Stitch(join._children, 0);
      cs.copyAll(left._children, 0, left._len);
      cs.copyAll(this._children, 0, idx - 1);
      if (nodes[0] != null)
        cs.copyOne(nodes[0]);
      cs.copyOne(nodes[1]);
      if (nodes[2] != null)
        cs.copyOne(nodes[2]);
      cs.copyAll(this._children, idx + 2, this._len);
      return [null, join, right];
    }
    if (right != null && newLen + right._len <= this._settings.branchingFactor()) {
      const join = new Branch(this._level, newLen + right._len, settings);
      const ks = new Stitch(join._keys, 0);
      ks.copyAll(this._keys, 0, idx - 1);
      if (nodes[0] != null)
        ks.copyOne(nodes[0].maxKey());
      ks.copyOne(nodes[1].maxKey());
      if (nodes[2] != null)
        ks.copyOne(nodes[2].maxKey());
      ks.copyAll(this._keys, idx + 2, this._len);
      ks.copyAll(right._keys, 0, right._len);
      if (this._addresses != null || right._addresses != null) {
        const as = new Stitch(join.ensureAddresses(), 0);
        as.copyAll(this._addresses, 0, idx - 1);
        if (nodes[0] != null)
          as.copyOne(leftChanged ? null : this.address(idx - 1));
        as.copyOne(null);
        if (nodes[2] != null)
          as.copyOne(rightChanged ? null : this.address(idx + 1));
        as.copyAll(this._addresses, idx + 2, this._len);
        as.copyAll(right._addresses, 0, right._len);
      }
      join.ensureChildren();
      const cs = new Stitch(join._children, 0);
      cs.copyAll(this._children, 0, idx - 1);
      if (nodes[0] != null)
        cs.copyOne(nodes[0]);
      cs.copyOne(nodes[1]);
      if (nodes[2] != null)
        cs.copyOne(nodes[2]);
      cs.copyAll(this._children, idx + 2, this._len);
      cs.copyAll(right._children, 0, right._len);
      return [left, join, null];
    }
    if (left != null && (right == null || left._len >= right._len)) {
      const totalLen = left._len + newLen;
      const newLeftLen = totalLen >>> 1;
      const newCenterLen = totalLen - newLeftLen;
      const newLeft = new Branch(this._level, newLeftLen, settings);
      const newCenter = new Branch(this._level, newCenterLen, settings);
      ArrayUtil.copy(left._keys, 0, newLeftLen, newLeft._keys, 0);
      const ks = new Stitch(newCenter._keys, 0);
      ks.copyAll(left._keys, newLeftLen, left._len);
      ks.copyAll(this._keys, 0, idx - 1);
      if (nodes[0] != null)
        ks.copyOne(nodes[0].maxKey());
      ks.copyOne(nodes[1].maxKey());
      if (nodes[2] != null)
        ks.copyOne(nodes[2].maxKey());
      ks.copyAll(this._keys, idx + 2, this._len);
      if (left._addresses != null) {
        ArrayUtil.copy(left._addresses, 0, newLeftLen, newLeft.ensureAddresses(), 0);
      }
      if (left._children != null) {
        ArrayUtil.copy(left._children, 0, newLeftLen, newLeft.ensureChildren(), 0);
      }
      if (left._addresses != null || this._addresses != null) {
        const as = new Stitch(newCenter.ensureAddresses(), 0);
        as.copyAll(left._addresses, newLeftLen, left._len);
        as.copyAll(this._addresses, 0, idx - 1);
        if (nodes[0] != null)
          as.copyOne(leftChanged ? null : this.address(idx - 1));
        as.copyOne(null);
        if (nodes[2] != null)
          as.copyOne(rightChanged ? null : this.address(idx + 1));
        as.copyAll(this._addresses, idx + 2, this._len);
      }
      newCenter.ensureChildren();
      const cs = new Stitch(newCenter._children, 0);
      cs.copyAll(left._children, newLeftLen, left._len);
      cs.copyAll(this._children, 0, idx - 1);
      if (nodes[0] != null)
        cs.copyOne(nodes[0]);
      cs.copyOne(nodes[1]);
      if (nodes[2] != null)
        cs.copyOne(nodes[2]);
      cs.copyAll(this._children, idx + 2, this._len);
      return [newLeft, newCenter, right];
    }
    if (right != null) {
      const totalLen = newLen + right._len;
      const newCenterLen = totalLen >>> 1;
      const newRightLen = totalLen - newCenterLen;
      const rightHead = right._len - newRightLen;
      const newCenter = new Branch(this._level, newCenterLen, settings);
      const newRight = new Branch(this._level, newRightLen, settings);
      const ks = new Stitch(newCenter._keys, 0);
      ks.copyAll(this._keys, 0, idx - 1);
      if (nodes[0] != null)
        ks.copyOne(nodes[0].maxKey());
      ks.copyOne(nodes[1].maxKey());
      if (nodes[2] != null)
        ks.copyOne(nodes[2].maxKey());
      ks.copyAll(this._keys, idx + 2, this._len);
      ks.copyAll(right._keys, 0, rightHead);
      ArrayUtil.copy(right._keys, rightHead, right._len, newRight._keys, 0);
      if (this._addresses != null || right._addresses != null) {
        const as = new Stitch(newCenter.ensureAddresses(), 0);
        as.copyAll(this._addresses, 0, idx - 1);
        if (nodes[0] != null)
          as.copyOne(leftChanged ? null : this.address(idx - 1));
        as.copyOne(null);
        if (nodes[2] != null)
          as.copyOne(rightChanged ? null : this.address(idx + 1));
        as.copyAll(this._addresses, idx + 2, this._len);
        as.copyAll(right._addresses, 0, rightHead);
      }
      newCenter.ensureChildren();
      const cs = new Stitch(newCenter._children, 0);
      cs.copyAll(this._children, 0, idx - 1);
      if (nodes[0] != null)
        cs.copyOne(nodes[0]);
      cs.copyOne(nodes[1]);
      if (nodes[2] != null)
        cs.copyOne(nodes[2]);
      cs.copyAll(this._children, idx + 2, this._len);
      cs.copyAll(right._children, 0, rightHead);
      if (right._addresses != null) {
        ArrayUtil.copy(right._addresses, rightHead, right._len, newRight.ensureAddresses(), 0);
      }
      if (right._children != null) {
        ArrayUtil.copy(right._children, rightHead, right._len, newRight.ensureChildren(), 0);
      }
      return [left, newCenter, newRight];
    }
    throw new Error("Unreachable");
  }
  walkAddresses(storage, onAddress) {
    for (let i = 0;i < this._len; i++) {
      const address = this.address(i);
      if (address != null) {
        if (!onAddress(address)) {
          continue;
        }
      }
      if (this._level > 1) {
        this.child(storage, i).walkAddresses(storage, onAddress);
      }
    }
  }
  store(storage) {
    this.ensureAddresses();
    for (let i = 0;i < this._len; i++) {
      if (this._addresses[i] == null) {
        const child = this._settings.readReference(this._children[i]);
        this.setAddress(i, child.store(storage));
      }
    }
    return storage.store(this);
  }
  str(storage, lvl) {
    const lines = [];
    for (let i = 0;i < this._len; i++) {
      lines.push(`
`);
      for (let j = 0;j < lvl; j++) {
        lines.push("| ");
      }
      lines.push(this._keys[i] + ": " + this.child(storage, i).str(storage, lvl + 1));
    }
    return lines.join("");
  }
  toString(sb, address, indent) {
    sb.push(indent);
    sb.push("Branch addr: " + address + " len: " + this._len + " ");
    for (let i = 0;i < this._len; i++) {
      sb.push(`
`);
      let child = null;
      if (this._children != null) {
        const ref = this._children[i];
        if (ref != null) {
          child = this._settings.readReference(ref);
        }
      }
      if (child != null) {
        child.toString(sb, this.address(i), indent + "  ");
      } else {
        sb.push(indent + "  " + this.address(i) + ": <lazy> ");
      }
    }
  }
}
Branch.EARLY_EXIT = EARLY_EXIT2;
Branch.UNCHANGED = UNCHANGED2;

// src/persistent_sorted_set_js/Chunk.js
class Chunk {
  constructor(set, keys, idx, end, asc, version) {
    this._set = set;
    this._keys = keys;
    this._idx = idx;
    this._end = end;
    this._asc = asc;
    this._version = version;
  }
  static fromSeq(seq) {
    const idx = seq._idx;
    const keys = seq._node._keys;
    const asc = seq._asc;
    let end;
    if (asc) {
      end = seq._node._len - 1;
      if (seq._keyTo != null) {
        while (end > idx && seq._cmp(keys[end], seq._keyTo) > 0) {
          end--;
        }
      }
    } else {
      end = 0;
      if (seq._keyTo != null) {
        while (end < idx && seq._cmp(keys[end], seq._keyTo) < 0) {
          end++;
        }
      }
    }
    return new Chunk(seq._set, keys, idx, end, asc, seq._version);
  }
  checkVersion() {
    if (this._version !== this._set._version) {
      throw new Error("Tovarisch, you are iterating and mutating a transient set at the same time!");
    }
  }
  dropFirst() {
    this.checkVersion();
    if (this._idx === this._end) {
      throw new Error("dropFirst of empty chunk");
    }
    return new Chunk(this._set, this._keys, this._asc ? this._idx + 1 : this._idx - 1, this._end, this._asc, this._version);
  }
  reduce(f, start) {
    this.checkVersion();
    let ret = f(start, this._keys[this._idx]);
    if (this._asc) {
      for (let x = this._idx + 1;x <= this._end; x++) {
        ret = f(ret, this._keys[x]);
      }
    } else {
      for (let x = this._idx - 1;x >= this._end; x--) {
        ret = f(ret, this._keys[x]);
      }
    }
    return ret;
  }
  nth(i, notFound = null) {
    this.checkVersion();
    if (i >= 0 && i < this.count()) {
      return this._asc ? this._keys[this._idx + i] : this._keys[this._idx - i];
    }
    return notFound;
  }
  count() {
    this.checkVersion();
    if (this._asc) {
      return this._end - this._idx + 1;
    } else {
      return this._idx - this._end + 1;
    }
  }
  toArray() {
    this.checkVersion();
    const arr = [];
    if (this._asc) {
      for (let i = this._idx;i <= this._end; i++) {
        arr.push(this._keys[i]);
      }
    } else {
      for (let i = this._idx;i >= this._end; i--) {
        arr.push(this._keys[i]);
      }
    }
    return arr;
  }
}

// src/persistent_sorted_set_js/Seq.js
class Seq {
  constructor(prev, set, parent, node, idx, keyTo, cmp, asc, version) {
    this._prev = prev;
    this._set = set;
    this._parent = parent;
    this._node = node;
    this._idx = idx;
    this._keyTo = keyTo;
    this._cmp = cmp;
    this._asc = asc;
    this._version = version;
  }
  checkVersion() {
    if (this._version !== this._set._version) {
      throw new Error("Tovarisch, you are iterating and mutating a transient set at the same time!");
    }
  }
  child() {
    return this._parent.node.child(this._set._storage, this._idx);
  }
  first() {
    this.checkVersion();
    return this._node._keys[this._idx];
  }
  over() {
    if (this._keyTo == null) {
      return false;
    }
    const c = this._cmp(this._node._keys[this._idx], this._keyTo);
    return this._asc ? c > 0 : c < 0;
  }
  advance() {
    this.checkVersion();
    if (this._node instanceof Leaf) {
      if (this._asc) {
        this._idx++;
        if (this._idx < this._node._len) {
          return !this.over();
        }
      } else {
        this._idx--;
        if (this._idx >= 0) {
          return !this.over();
        }
      }
      if (this._parent == null) {
        return false;
      }
      const parent = this._parent;
      this._node = parent._node;
      this._idx = parent._idx;
      this._parent = parent._parent;
      return this.advance();
    } else {
      if (this._asc) {
        this._idx++;
      } else {
        this._idx--;
      }
      if (this._asc && this._idx >= this._node._len) {
        if (this._parent == null) {
          return false;
        }
        const parent2 = this._parent;
        this._node = parent2._node;
        this._idx = parent2._idx;
        this._parent = parent2._parent;
        return this.advance();
      }
      if (!this._asc && this._idx < 0) {
        if (this._parent == null) {
          return false;
        }
        const parent2 = this._parent;
        this._node = parent2._node;
        this._idx = parent2._idx;
        this._parent = parent2._parent;
        return this.advance();
      }
      let node = this.child();
      const parent = new Seq(null, this._set, this._parent, this._node, this._idx, null, null, this._asc, this._version);
      while (node instanceof Branch) {
        const idx = this._asc ? 0 : node._len - 1;
        const seq = new Seq(null, this._set, parent, node, idx, null, null, this._asc, this._version);
        node = seq.child();
        parent._node = seq._node;
        parent._idx = seq._idx;
        parent._parent = seq._parent;
      }
      this._node = node;
      this._idx = this._asc ? 0 : node._len - 1;
      this._parent = parent;
      return !this.over();
    }
  }
  next() {
    const seq = new Seq(this._prev, this._set, this._parent, this._node, this._idx, this._keyTo, this._cmp, this._asc, this._version);
    if (seq.advance()) {
      return seq;
    }
    return null;
  }
  seek(to, cmp) {
    let seq = this;
    while (seq != null) {
      const c = cmp(seq.first(), to);
      if (c === 0) {
        return seq;
      }
      if (this._asc && c > 0) {
        return null;
      }
      if (!this._asc && c < 0) {
        return null;
      }
      seq = seq.next();
    }
    return null;
  }
  reduce(f, start) {
    let ret = start;
    let seq = this;
    while (seq != null) {
      ret = f(ret, seq.first());
      seq = seq.next();
    }
    return ret;
  }
  chunkedSeq() {
    if (this._node instanceof Leaf) {
      return Chunk.fromSeq(this);
    }
    return null;
  }
  toArray() {
    const arr = [];
    let seq = this;
    while (seq != null) {
      arr.push(seq.first());
      seq = seq.next();
    }
    return arr;
  }
  [Symbol.iterator]() {
    let seq = this;
    return {
      next() {
        if (seq == null) {
          return { done: true };
        }
        const value = seq.first();
        seq = seq.next();
        return { value, done: false };
      }
    };
  }
}

// src/persistent_sorted_set_js/RefType.js
var RefType = Object.freeze({
  STRONG: "STRONG",
  SOFT: "SOFT",
  WEAK: "WEAK"
});

// src/persistent_sorted_set_js/Settings.js
class Settings {
  constructor(branchingFactor = 0, refType = null, edit = null) {
    if (branchingFactor <= 0) {
      branchingFactor = 512;
    }
    if (refType == null) {
      refType = RefType.SOFT;
    }
    this._branchingFactor = branchingFactor;
    this._refType = refType;
    this._edit = edit;
  }
  minBranchingFactor() {
    return this._branchingFactor >>> 1;
  }
  branchingFactor() {
    return this._branchingFactor;
  }
  expandLen() {
    return 8;
  }
  refType() {
    return this._refType;
  }
  editable() {
    return this._edit != null && this._edit.value;
  }
  editableSettings(value) {
    if (this.editable()) {
      throw new Error("Already editable");
    }
    if (value !== true) {
      throw new Error("Value must be true");
    }
    return new Settings(this._branchingFactor, this._refType, { value });
  }
  persistent() {
    if (this._edit == null) {
      throw new Error("Not editable");
    }
    this._edit.value = false;
  }
  makeReference(value) {
    switch (this._refType) {
      case RefType.STRONG:
        return value;
      case RefType.SOFT:
      case RefType.WEAK:
        return new WeakRef(value);
      default:
        throw new Error("Unexpected refType: " + this._refType);
    }
  }
  readReference(ref) {
    return ref instanceof WeakRef ? ref.deref() : ref;
  }
}

// src/persistent_sorted_set_js/PersistentSortedSet.js
var EARLY_EXIT3 = [];
var UNCHANGED3 = [];

class PersistentSortedSet {
  constructor(cmp = null, storage = null, settings = null, address = null, root = null, count = 0, version = 0) {
    this._cmp = cmp || defaultComparator;
    this._storage = storage;
    this._settings = settings || new Settings;
    this._address = address;
    this._root = root || new Leaf(0, this._settings);
    this._count = count;
    this._version = version;
    this._hash = 0;
  }
  static empty(cmp = null) {
    return new PersistentSortedSet(cmp);
  }
  static from(arr, cmp = null) {
    let set = PersistentSortedSet.empty(cmp);
    for (const item of arr) {
      set = set.conj(item);
    }
    return set;
  }
  root() {
    let root = this._settings.readReference(this._root);
    if (root == null && this._address != null) {
      root = this._storage.restore(this._address);
      this._root = this._settings.makeReference(root);
    }
    return root;
  }
  editable() {
    return this._settings.editable();
  }
  comparator() {
    return this._cmp;
  }
  count() {
    if (this._count < 0) {
      this._count = this.root().count(this._storage);
    }
    return this._count;
  }
  isEmpty() {
    return this.count() === 0;
  }
  alterCount(delta) {
    return this._count < 0 ? this._count : this._count + delta;
  }
  contains(key) {
    return this.root().contains(this._storage, key, this._cmp);
  }
  has(key) {
    return this.contains(key);
  }
  get(key, notFound = null) {
    return this.contains(key) ? key : notFound;
  }
  conj(key) {
    const nodes = this.root().add(this._storage, key, this._cmp, this._settings);
    if (nodes === UNCHANGED3) {
      return this;
    }
    if (this.editable()) {
      if (nodes.length === 1) {
        this._address = null;
        this._root = nodes[0];
      } else if (nodes.length === 2) {
        const keys2 = [nodes[0].maxKey(), nodes[1].maxKey()];
        this._address = null;
        this._root = new Branch(nodes[0].level() + 1, 2, keys2, null, nodes, this._settings);
      }
      this._count = this.alterCount(1);
      this._version += 1;
      return this;
    }
    if (nodes.length === 1) {
      return new PersistentSortedSet(this._cmp, this._storage, this._settings, null, nodes[0], this.alterCount(1), this._version + 1);
    }
    const keys = [nodes[0].maxKey(), nodes[1].maxKey()];
    const newRoot = new Branch(nodes[0].level() + 1, 2, keys, null, nodes, this._settings);
    return new PersistentSortedSet(this._cmp, this._storage, this._settings, null, newRoot, this.alterCount(1), this._version + 1);
  }
  disj(key) {
    const nodes = this.root().remove(this._storage, key, null, null, this._cmp, this._settings);
    if (nodes === UNCHANGED3) {
      return this;
    }
    if (nodes === EARLY_EXIT3) {
      this._address = null;
      this._count = this.alterCount(-1);
      this._version += 1;
      return this;
    }
    let newRoot = nodes[1];
    if (this.editable()) {
      if (newRoot instanceof Branch && newRoot._len === 1) {
        newRoot = newRoot.child(this._storage, 0);
      }
      this._address = null;
      this._root = newRoot;
      this._count = this.alterCount(-1);
      this._version += 1;
      return this;
    }
    if (newRoot instanceof Branch && newRoot._len === 1) {
      newRoot = newRoot.child(this._storage, 0);
      return new PersistentSortedSet(this._cmp, this._storage, this._settings, null, newRoot, this.alterCount(-1), this._version + 1);
    }
    return new PersistentSortedSet(this._cmp, this._storage, this._settings, null, newRoot, this.alterCount(-1), this._version + 1);
  }
  slice(from = null, to = null) {
    let seq = null;
    let node = this.root();
    if (node.len() === 0) {
      return null;
    }
    if (from == null) {
      while (true) {
        if (node instanceof Branch) {
          seq = new Seq(null, this, seq, node, 0, null, null, true, this._version);
          node = node.child(this._storage, 0);
        } else {
          seq = new Seq(null, this, seq, node, 0, to, this._cmp, true, this._version);
          return seq.over() ? null : seq;
        }
      }
    }
    while (true) {
      let idx = node.searchFirst(from, this._cmp);
      if (idx < 0)
        idx = -(idx + 1);
      if (idx === node._len)
        return null;
      if (node instanceof Branch) {
        seq = new Seq(null, this, seq, node, idx, null, null, true, this._version);
        node = node.child(this._storage, idx);
      } else {
        seq = new Seq(null, this, seq, node, idx, to, this._cmp, true, this._version);
        return seq.over() ? null : seq;
      }
    }
  }
  rslice(from = null, to = null) {
    let seq = null;
    let node = this.root();
    if (node.len() === 0) {
      return null;
    }
    if (from == null) {
      while (true) {
        const idx = node._len - 1;
        if (node instanceof Branch) {
          seq = new Seq(null, this, seq, node, idx, null, null, false, this._version);
          node = node.child(this._storage, idx);
        } else {
          seq = new Seq(null, this, seq, node, idx, to, this._cmp, false, this._version);
          return seq.over() ? null : seq;
        }
      }
    }
    while (true) {
      if (node instanceof Branch) {
        let idx = node.searchLast(from, this._cmp) + 1;
        if (idx === node._len)
          idx--;
        seq = new Seq(null, this, seq, node, idx, null, null, false, this._version);
        node = node.child(this._storage, idx);
      } else {
        const idx = node.searchLast(from, this._cmp);
        if (idx === -1) {
          seq = new Seq(null, this, seq, node, 0, to, this._cmp, false, this._version);
          return seq.advance() ? seq : null;
        } else {
          seq = new Seq(null, this, seq, node, idx, to, this._cmp, false, this._version);
          return seq.over() ? null : seq;
        }
      }
    }
  }
  seq() {
    return this.slice();
  }
  rseq() {
    return this.rslice();
  }
  toArray() {
    const arr = [];
    const seq = this.seq();
    if (seq != null) {
      return seq.toArray();
    }
    return arr;
  }
  [Symbol.iterator]() {
    const seq = this.seq();
    if (seq == null) {
      return {
        next() {
          return { done: true };
        }
      };
    }
    return seq[Symbol.iterator]();
  }
  forEach(fn) {
    let i = 0;
    for (const item of this) {
      fn(item, i++, this);
    }
  }
  map(fn) {
    const result = [];
    let i = 0;
    for (const item of this) {
      result.push(fn(item, i++, this));
    }
    return result;
  }
  filter(pred) {
    let result = PersistentSortedSet.empty(this._cmp);
    let i = 0;
    for (const item of this) {
      if (pred(item, i++, this)) {
        result = result.conj(item);
      }
    }
    return result;
  }
  reduce(fn, init) {
    const seq = this.seq();
    if (seq == null) {
      return init;
    }
    return seq.reduce(fn, init);
  }
  asTransient() {
    if (this.editable()) {
      throw new Error("Already transient");
    }
    return new PersistentSortedSet(this._cmp, this._storage, this._settings.editableSettings(true), this._address, this._root, this._count, this._version);
  }
  persistent() {
    if (!this.editable()) {
      throw new Error("Already persistent");
    }
    this._settings.persistent();
    return this;
  }
  store(storage = null) {
    if (storage != null) {
      this._storage = storage;
    }
    if (this._storage == null) {
      throw new Error("No storage backend provided");
    }
    if (this._address == null) {
      const root = this._settings.readReference(this._root);
      this._address = root.store(this._storage);
      this._root = this._settings.makeReference(root);
    }
    return this._address;
  }
  walkAddresses(onAddress) {
    if (this._address != null) {
      if (!onAddress(this._address)) {
        return;
      }
    }
    this.root().walkAddresses(this._storage, onAddress);
  }
  str() {
    return this.root().str(this._storage, 0);
  }
  toString() {
    return "#{" + this.toArray().join(" ") + "}";
  }
  hashCode() {
    if (this._hash === 0) {
      let hash = 0;
      for (const item of this) {
        hash += typeof item === "object" && item !== null && typeof item.hashCode === "function" ? item.hashCode() : JSON.stringify(item).split("").reduce((a, b) => {
          a = (a << 5) - a + b.charCodeAt(0);
          return a & a;
        }, 0);
      }
      this._hash = hash;
    }
    return this._hash;
  }
  equals(other) {
    if (this === other)
      return true;
    if (!(other instanceof PersistentSortedSet))
      return false;
    if (this.count() !== other.count())
      return false;
    const seq1 = this.seq();
    const seq2 = other.seq();
    let s1 = seq1;
    let s2 = seq2;
    while (s1 != null && s2 != null) {
      if (this._cmp(s1.first(), s2.first()) !== 0) {
        return false;
      }
      s1 = s1.next();
      s2 = s2.next();
    }
    return s1 == null && s2 == null;
  }
}
PersistentSortedSet.EARLY_EXIT = EARLY_EXIT3;
PersistentSortedSet.UNCHANGED = UNCHANGED3;

// src/persistent_sorted_set_js/IStorage.js
class IStorage {
  restore(address) {
    throw new Error("restore() must be implemented");
  }
  accessed(address) {
  }
  store(node) {
    throw new Error("store() must be implemented");
  }
}

// src/persistent_sorted_set_js/NodeFactory.js
class NodeFactory {
  static restore(level, keys, addresses, settings) {
    if (level === 0) {
      return new Leaf(keys.length, keys, settings);
    } else {
      return new Branch(level, keys.length, keys, addresses, null, settings);
    }
  }
}
export {
  defaultComparator,
  Stitch,
  Settings,
  Seq,
  RefType,
  PersistentSortedSet,
  NodeFactory,
  Leaf,
  IStorage,
  Chunk,
  Branch,
  ArrayUtil,
  ANode
};
